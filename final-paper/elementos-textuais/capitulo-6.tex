\chapter{Resposta a colisão}

A resposta a colisões é uma etapa fundamental em qualquer sistema de simulação física interativa. Após detectar que dois corpos estão penetrando um ao outro, é necessário aplicar um conjunto de correções que restaurem a plausibilidade física do movimento sem introduzir instabilidades.  Neste capítulo apresentamos os princípios clássicos, as formulações modernas e a relação direta entre métodos geométricos da fase de detecção, tais como o vetor de translação mínima (MTV), e métodos baseados em partículas e restrições, como o modelo proposto por \citeonline{jakobsen2001advanced}.

\section{Contexto Histórico e Motivação}

Os primeiros motores de física utilizados em gráficos interativos nos anos 1990 empregavam modelos altamente simplificados baseados em impulsos (impulse-based methods), com foco especial em simulações rígidas newtonianas. Embora fisicamente corretos, esses métodos eram computacionalmente caros e exigiam sistemas robustos para resolver forças, torques e empilhamentos estáveis em tempo real.

Já os chamados métodos baseados em penalidades tratam o contato inserindo molas nos pontos de penetração. Embora seja muito simples de implementar, esse método apresenta diversas desvantagens sérias. Por exemplo, é difícil escolher constantes de mola adequadas de forma que, por um lado, os objetos não penetrem demais e, por outro lado, o sistema resultante não se torne instável.

\citeonline{jakobsen2001advanced} apresentou um método de simulação baseado em projeção de posição (Position Based Dynamics). Em vez de trabalhar com forças e integrações diferenciais sobre acelerações, os vértices que fazem parte da colisão são simplesmente projetados para fora do obstáculo. Por projeção, em termos gerais, entendemos mover o ponto o mínimo possível até que ele esteja livre do obstáculo.

\section{Fundamentos da Resposta a Colisão}

A resposta a colisões consiste, essencialmente, em duas operações principais:
\begin{enumerate}
	\item \textbf{Correção de Posição}: remover a interpenetração entre dois corpos.
	\item \textbf{Correção de Velocidade}: ajustar ou anular componentes da velocidade que provoquem novo contato imediato.
\end{enumerate}

Embora os motores tradicionais realizem ambas as etapas, muitos sistemas baseados em PBD focam totalmente na correção de posições, derivando velocidades implicitamente a partir da diferença entre posições sucessivas.

\section{Projeção da posição pelo método Jakobsen}

A resposta à uma colisão é composta de dois passos. O primeiro passo consiste em separar os elementos dos objetos (vértice, aresta ou face) que estão se intersectando. Este passo é puramente geométrico, já que é executado movendo as partículas na geometria da colisão.

O segundo passo é um processo de relaxamento iterativo no qual os elementos dos objetos que estão envolvidos na colisão encontram as suas posições apropriadas usando as restrições como suporte.

Se dois objetos convexos A e B colidem o processo de separação requer três parâmetros: os pontos $p_A$ de contato de A, os pontos $p_B$ de contato de B e o ponto $q$ que a simulação assume onde os dois objetos estão em contato chamado de ponto de projeção.

O ponto de projeção coincide com o plano de separação $H(\vec{v}, \delta)$ nas coordenadas locais do objeto, dessa forma como regra geral basta mover os pontos de $p_A$ em direção $H(\vec{v}, \delta)$. Considere dois casos de colisão:

\section{Algoritmo de Expansão de Politopos (EPA)}

Para realizar a separação de dois objetos usando o algoritmo SAT basta calcularmos o MTV como visto na seção \ref{sec:sat}. Já para o GJK é preciso fazer um segundo passo, uma extensão do algoritmo que nos permite encontrar a normal correta e profundidade das colisões.

O Algoritmo de Expansão de Politopos (do inglês Expanding Polytope Algorithm, EPA) cria um polítopo (ou polígono) dentro da Diferença de Minkowski e iterativamente expandi-lo até atingirmos a borda da Diferença de Minkowski. EPA executa essa tarefa utilizando a mesma função de suporte utilizada nos demais algoritmos e a mesma noção de um simplex.

Este algoritmo é uma extensão porque sua entrada é o Simplex final do GJK que contém a origem e encontra o MTV. A distância entre o ponto mais próximo com a origem é a profundidade de penetração ($\delta$). Além disso, o vetor normal para o ponto mais próximo é a direção de separação (ponto de contato). A solução ingênua é usar o normal da face mais próxima da origem, porém um simplex não precisa conter nenhuma das faces do polígono original, o quê pode acabar com uma normal incorreta.

O algoritmo expande o Simplex adicionando vértices a ele até encontrarmos a normal mais próxima de uma face que está no polígono original.

\begin{algorithm}[H]
	\caption{EPA}
	\KwIn{Simplex}
	\KwOut{separation $v$, penetration $\delta$}
	
	\For{$i \leftarrow 0$ \KwTo $i < MAX\_ITERATION$}{
		e $\leftarrow$ Encontrar aresta mais próxima a origem \\
		p $\leftarrow$ Calcular novo ponto de suporte na direção da normal de e \\
		$\delta \leftarrow p \cdot normal(e)$ \\
		\If{$|\delta - length(e)| < TOLERANCE$}{
			\KwRet{normal(e), $\delta$}
		}
		
		Adicionar ponto ao simplex
	}
\end{algorithm}

É importante limitar o número de iterações para evitar que a rotina entre em loop infinito em casos degenerados, como esse algoritmo converge rapidamente uma constante igual a 30 é um bom limite superior. Matematicamente a distância deve ser igual a zero, mas por conta da artimética de ponto flutuante, uma tolerância pequena deve ser aceita, como $10^{-3}$.