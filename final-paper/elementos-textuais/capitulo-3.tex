\chapter{Detecção de Colisões}

A detecção de colisões é um componente fundamental em sistemas de simulação física e em animações baseadas em partículas. Esse processo identifica quando dois ou mais objetos entram em contato, determina pontos de interseção e, quando necessário, fornece informações como vetores de penetração e normais que servirão de entrada para a etapa subsequente de resposta física. Em contextos interativos em tempo real, a precisão geométrica absoluta costuma ser sacrificada em favor da eficiência computacional, desde que o comportamento resultante se mantenha visualmente verossímil.

Este capítulo introduz os principais conceitos utilizados no âmbito deste trabalho, descrevendo as representações geométricas mais comuns para objetos convexos e apresentando dois algoritmos amplamente empregados em detecção de colisões: o Teorema do Eixo Separador (SAT) e o algoritmo Gilbert--Johnson--Keerthi (GJK). Ambos operam eficientemente em formas convexas e constituem a base de vários motores físicos modernos.

\section{Polígonos convexos}

Um objeto geométrico é definido como um conjunto não vazio, limitado e fechado de pontos. A propriedade de ser fechado implica que sua fronteira pertence ao próprio conjunto, enquanto a limitação garante que exista uma esfera de raio finito que contenha todos os seus pontos. Um plano, por exemplo, é fechado, mas não limitado.

% \textbf{(INSERIR IMAGEM DE FORMA CONVEXA E NÃO-CONVEXA)}
\begin{figure}[h]
	\centering
	\includesvg[width=0.6\linewidth]{poligono-convexo-concavo}
	\caption{Comparação entre polígono convexo (à esquerda) e polígono côncavo (à direita).}
	\label{fig:poligonos}
\end{figure}

Uma forma é considerada \textit{convexa} se, para quaisquer dois pontos contidos nessa forma, todo o segmento que os une também estiver contido nela. Uma consequência prática é que, para qualquer linha que atravesse o objeto, esta o intersecta em no máximo dois pontos. Formas não convexas podem ser tratadas como composições de múltiplas partes convexas, o que permite a aplicação direta de algoritmos especializados.

\section{Teorema do Eixo Separador (SAT)}
\label{sec:sat}

O Teorema do Eixo Separador (\textit{Separating Axis Theorem}, SAT) é um dos métodos mais difundidos para detecção de colisão entre polígonos convexos. Além de identificar a presença ou ausência de interseção, o SAT também pode ser utilizado para calcular o \textit{vetor de translação mínima} (\textit{Minimum Translation Vector}, MTV), útil para correções geométricas e resposta física.

O SAT é um algoritmo genérico rápido que pode remover a necessidade de ter código de detecção de colisão para cada par tipo de forma, reduzindo assim o código e a manutenção. Ele se baseia no teorema geométrico que afirma:

\begin{teorema}
	Dois polígonos convexos $A$ e $B$ não se intersectam se, e somente se, existir um eixo (reta) sobre o qual as projeções de $A$ e $B$ não se sobrepõem.
	\label{theo:sat}
\end{teorema}

Tal eixo é denominado \textit{eixo separador}. Em termos computacionais, o algoritmo testa um conjunto finito de eixos candidatos. Para polígonos, os candidatos suficientes são as normais das faces (ou arestas, em 2D) de ambos os objetos.

\begin{figure}[h]
	\centering
	\includesvg[width=0.2\linewidth]{eixo-separador}
	\caption{Eixo separador entre dois polígonos em 2D}
	\label{fig:eixo-separador}
\end{figure}

\subsection*{Projeção sobre um eixo}

Dado um eixo unitário $\hat{n}$ e um conjunto de vértices $\{ v \}$ de um polígono, a projeção gera um intervalo escalar $[min, max]$ definido por:
\begin{align}
	min &= \min_i (\hat{n} \cdot \vec{v}_i) \\
	max &= \max_i (\hat{n} \cdot \vec{v}_i)
\end{align}

A verificação de sobreposição entre dois intervalos $[min_A, max_A]$ e $[min_B, max_B]$ é dada pela condição:
\begin{equation}
	\text{Sobreposição} \iff max_A \geq min_B \quad \land \quad max_B \geq min_A
\end{equation}

Se essa condição falhar em qualquer eixo candidato, os objetos estão separados e o algoritmo pode encerrar imediatamente (\textit{early exit}).

\subsection*{Algoritmo de Interseção e MTV}

O SAT pode ser estendido para calcular a penetração mínima. Caso todos os eixos apresentem sobreposição, a menor sobreposição encontrada corresponde à magnitude do vetor necessário para resolver a colisão.

\begin{algorithm}[H]
	\caption{SAT com cálculo do MTV}
	\KwIn{Polígonos convexos $A$ e $B$}
	\KwOut{$\vec{d}$ e $\delta$, ou falso}
	$\vec{d} \leftarrow \vec{0}$ \\
	$\delta \leftarrow \infty$ \\
	\ForEach{aresta $\hat{n}$ de A e B}{
		$\hat{n} \leftarrow$ normal unitária de $\hat{n}$ \\
		$p_1 \leftarrow$ Projeção de $A$ \\
		$p_2 \leftarrow$ Projeção de $B$ \\
		$\Delta \leftarrow$ sobreposição entre $p_1$ e $p_2$ \\
		\If{$\Delta \leq$ TOLERÂNCIA}{
			\Return{False}
		}
		\If{$\Delta < \delta$}{
			$\delta \leftarrow \Delta$ \\
			$\vec{d} \leftarrow \hat{n}$
		}
	}
	\Return{$\vec{d}$, $\delta$}
	\label{al:sat_mtv}
\end{algorithm}

\begin{figure}[h]
	\centering
	\includesvg[width=0.6\linewidth]{projecao-eixos}
	\caption{Projeção e intersecção de eixos}
	\label{fig:projecao-eixos}
\end{figure}

O método possui complexidade linear no número de arestas e é bastante eficiente para polígonos convexos em 2D. Em 3D, entretanto, o número de eixos candidatos cresce significativamente, reduzindo sua praticidade em relação a alternativas como o GJK.

\section{Algoritmo Gilbert–Johnson–Keerthi (GJK)}

O algoritmo de \citeonline{gjk} calcula a distância mínima entre dois conjuntos convexos utilizando apenas uma \textit{função de suporte} capaz de retornar o ponto mais distante de um conjunto em uma direção arbitrária. Esse algoritmo é particularmente eficiente em 3D e é amplamente adotado em motores físicos por sua robustez e excelente desempenho.

\subsection*{Soma de Minkowski}

O algoritmo GJK depende muito de um conceito chamado soma de Minkowski de dois objetos convexos A e B que é definida por:

\begin{equation}
	A + B = \{\vec{x} + \vec{y} \mid \vec{x} \in A, \vec{y} \in B \},
\end{equation}

O objeto A + B é o conjunto de pontos obtido por um processo de varredura que translada o centro de massa de B para cada ponto de A, ou seja, faz-se uma cópia do objeto B centrado em cada ponto de A

\begin{figure}[h]
	\centering
	\includesvg[width=0.6\linewidth]{soma-minkowski}
	\caption{Soma de Minkowski}
	\label{fig:soma-minkowski}
\end{figure}

Uma propriedade muito útil da soma de Minkowski é o fato de que a soma de dois objetos convexos é um objeto convexo. O algoritmo GJK se beneficia dessas propriedades usando uma operação informalmente chamada de \textit{diferença de Minkowski}

\begin{equation}
	A - B = \{\vec{x} - \vec{y} \mid \vec{x} \in A, \vec{y} \in B \},
\end{equation}

A diferença de Minkowski pode ser pensado como um processo de varredura que calcula o vetor distancia para cada ponto de B em A. Essa operação continua sendo a soma de Minkowski (a soma da diferença) mas, neste trabalho, usaremos esse termo para referir a essa operação quando necessário. Dessa forma, caso a distância entre dois pontos seja zero (interseção), podemos confirmar há colisão entre os dois objetos. Esse vetor também coincide com a origem, logo elaboramos nosso próximo teorema:

\begin{teorema}
	Os conjuntos $A$ e $B$ colidem se, e somente se, o ponto de origem $(0, 0)$ estiver contido em $A - B$.
\end{teorema}

Executar essa operação exige $|A| * |B| * 2$ subtrações. Isso é significativo porque uma forma é composta de um número infinito de pontos.  A grande coisa sobre GJK é que você realmente não precisa calcular a diferença de Minkowski para todos os vértices. Uma vez que ambas as formas são convexas e definidas por vértices só precisamos realizar esta operação nos vértices mais externos.

Dessa forma, não queremos calcular a diferença de Minkowski. Em vez disso, queremos apenas saber se a Diferença de Minkowski contém ou não a origem. Se isso acontecer, então sabemos que as formas estão se cruzando, se não o faz, então elas não são.

Isso é feito construindo iterativamente um polígono dentro da diferença de Minkowski que tenta incluir a origem. Se o polígono que construímos contém a origem, então podemos dizer que a Diferença de Minkowski contém a origem, e também que há interseção entre os dois objetos. Este polígono que queremos construir deve ser da forma mais elementar possível, no caso de 2D um triângulo, no caso de 3D um poliedro, por isso é chamado de Simplex.

\subsection*{Função de Suporte}

O algoritmo GJK começa com um simplex inicial e o refina iterativamente adicionando pontos encontrados usando a função de suporte em uma direção que aponta para a origem. Esse processo continua até que a origem seja encontrada dentro do simplex, indicando uma colisão, ou até que se determine que a origem não está contida, o que significa que não há colisão.

A função de suporte deve retornar o ponto mais distante em uma direção dentro da Diferença de Minkowski. Isso cria um Simplex que contém uma área máxima, aumentando, portanto, a chance de que o algoritmo termine rapidamente. Além disso, podemos usar o fato de que todos os pontos retornados desta forma estão na borda da diferença de Minkowski e, portanto, se não pudermos adicionar um ponto além da origem ao longo de alguma direção, sabemos que a diferença de Minkowski não contém a origem. Isso aumenta as chances de o algoritmo sair rapidamente em casos de não interseção.

Calcular explicitamente a geometria completa de $A \ominus B$ é computacionalmente proibitivo. O GJK contorna isso utilizando uma \textit{Função de Suporte} $S(\vec{d})$, que retorna o ponto de um corpo mais extremo em uma dada direção $\vec{d}$.

\subsection*{Construção iterativa do simplex}

O algoritmo busca determinar se a origem está contida em $A - B$ construindo iterativamente um \textit{simplex} — uma forma geométrica simples (ponto, segmento, triângulo ou tetraedro) — dentro da Diferença de Minkowski.

\begin{algorithm}[H]
	\caption{GJK}
	\LinesNumbered
	\KwIn{Polígonos convexos $A$ e $B$}
	\KwOut{Verdadeiro se ocorreu colisão}
	
	Escolhe-se uma direção inicial $\vec{d}$; \\
	$p \leftarrow \text{support}(A - B,\ \vec{d})$ \\
	\If{$p \cdot \vec{d} < 0$}{
		\Return{False}
	}
	Atualiza-se o simplex com $p$ e calcula-se nova direção $\vec{d}$; \\
	Itera-se até que o simplex contenha a origem ou seja possível concluir ausência de interseção.
\end{algorithm}

O GJK é eficiente e converge rapidamente na prática, sendo mais apropriado que o SAT em cenários tridimensionais e em motores físicos de uso geral.
