\chapter{Método Simplificado de Jakobsen}

O método proposto por \citeonline{jakobsen2001advanced} introduziu uma abordagem simples e eficiente para simulação de sistemas físicos em tempo real, especialmente voltada para jogos e animações interativas.  
Ele descreve uma abordagem eficiente e intuitiva para simular corpos deformáveis e sistemas articulados, utilizando um modelo de partículas e restrições geométricas. 

A principal motivação do método é eliminar a necessidade de resolver sistemas diferenciais rígidos e instáveis em tempo real, substituindo a abordagem de forças por correções geométricas iterativas entre partículas conectadas.  
Essa simplificação permite que a simulação mantenha um comportamento visualmente realista, mesmo sob grandes forças ou passos de tempo relativamente amplos.

\section{Métodos Numéricos em Simulação}

A simulação de movimento depende da solução numérica das equações diferenciais que descrevem a dinâmica dos corpos.  
Diversos métodos de integração podem ser utilizados, cada um com um equilíbrio distinto entre precisão, estabilidade e custo computacional.

\subsection{Método de Euler}

O método de Euler explícito é o mais simples e intuitivo. Ele atualiza a posição e a velocidade de acordo com a aceleração atual:

\begin{align}
	\vec{v}_{t+\Delta t} &= \vec{v}_t + \vec{a}_t \Delta t \\
	\vec{x}_{t+\Delta t} &= \vec{x}_t + \vec{v}_t \Delta t
\end{align}

Apesar de sua simplicidade, o método de Euler tende a ser numericamente instável, especialmente em sistemas oscilatórios (como molas), pois o erro de integração cresce rapidamente ao longo do tempo.

\subsection{Método Semi-implícito de Euler}

Uma variação estável do método de Euler consiste em atualizar primeiro a velocidade e depois a posição, utilizando a nova velocidade no cálculo:

\begin{align}
	\vec{v}_{t+\Delta t} &= \vec{v}_t + \vec{a}_t \Delta t \\
	\vec{x}_{t+\Delta t} &= \vec{x}_t + \vec{v}_{t+\Delta t} \Delta t
\end{align}

Essa pequena modificação melhora a conservação de energia e reduz a instabilidade numérica, sendo amplamente utilizada em motores de física em tempo real.

\subsection{Integração de Verlet}

O método de Verlet é uma alternativa amplamente adotada em simulações físicas de partículas. É um método estável, sua velocidade é calculada implicitamente o quê mantém sua posição e velocidade em sincronia, muito popular em simulação de dinâmica molecular. 

\begin{equation}
	\vec{x}_{t+\Delta t} = 2\vec{x}_t - \vec{x}_{t-\Delta t} + \vec{a}_t \Delta t^2
\end{equation}

O método de Verlet é estável e eficiente, especialmente em sistemas sujeitos a restrições geométricas além de eliminar a necessidade de armazenar explicitamente a velocidade, utilizando as posições atual e anterior para estimar a nova posição:

\section{Restrições Geométricas}

O sucesso de \citeonline{jakobsen2001advanced} não está relacionado apenas ao método numérico, mas foi conectar ideias simples para construir objetos maiores e complexos. Isso é feito atribuindo relações geométrica entre partículas.

Dessa forma objetos físicos são representados como um conjunto de \textbf{partículas} conectadas por \textbf{restrições} geométricas. As restrições definem relações que devem ser mantidas entre partículas.  

\subsection{Restrição Linear}

O caso mais comum é a \textbf{restrição linear} (ou restrição de distância), que mantém uma distância fixa $d$ entre duas partículas $i$ e $j$. Dessa forma o conjunto de partículas devem satisfazer a todo instante uma coleção de inequações unilaterais representadas na forma:

\begin{equation}
	|\vec{x_i} - \vec{x_j}| - d = 0
	\label{eq:linear_constraint}
\end{equation}

Mesmo que as posições das partículas estejam inicialmente corretas, depois de um passo de simulação a distância entre elas pode se tornar inválidas (através de forças externas, por exemplo). Para corrigir sua distância devemos mover (projetar) elas de tal forma que satisfaça \ref{eq:linear_constraint}.

\textbf{Inserir figura}

A essência de uma restrição é a projeção. Deve-se encontrar o movimento mínimo que a satisfaça. O efeito de uma restrição linear pode representar conectar duas partículas com uma haste rígida mas também projetar o ponto em um círculo ao redor do ponto de ancoragem.

\begin{algorithm}[H]
	\caption{Restrição Linear}
	$\vec{\delta} \leftarrow x_2 - x_1$ \\
	$c \leftarrow \frac{|\vec{\delta}| - d}{|\vec{\delta}|}$ \\
	$x_1 \leftarrow x_1 - \vec{\delta}*\epsilon*c$ \\
	$x_2 \leftarrow x_2 + \vec{\delta}*\epsilon*c$ \\
	\label{al:linear_constraint}
\end{algorithm}

O pseudocódigo \ref{al:linear_constraint} irá separar ou aproximar as partículas de tal forma que satisfaçam a distancia $d$. Essa situação é comparável a um sistema de molas interconectadas entre partículas de rigidez que tendem para o infinito ou a uma haste rígida separando as duas partículas.

\subsection{Restrição de Revolução}

Na animação física queremos muitas vezes que uma partícula gire em torno de um eixo. Isso é feito de forma simples, basta ter uma partícula em comum cuja função seja ser um eixo de rotação.

\textbf{Inserir figura}

Uma outra forma de fazer isso é usar uma restrição linear entre duas partículas com $d=0$.

\subsection{Restrição Angular}

Em muitas situações em animação física é desejável que o ângulo formado entre duas partículas esteja restrito a um intervalo válido. Isso pode ser feito de forma simples aplicando uma restrição linear caso a distância entre duas partículas seja menor que um limiar. Ou seja, satisfazer a inequação abaixo

$$|x_2 - x_1| > d$$

Com essa restrição conseguimos relações geométricas para joelhos e cotovelos de uma criatura que não podem dobrar além de ângulo máximo.

A rotina para essa restrição é tão simples quanto usar um condicional junto com o algoritmo de restrição linear.

\begin{algorithm}
	\caption{Restrição Angular}
	$\vec{\delta} \leftarrow \vec{x_2} - \vec{x_1}$ \\
	\If{$\vec{|\delta|} < d$}{
		$c \leftarrow \frac{|\vec{\delta}| - d}{|\vec{\delta}|}$ \\
		$x_1 \leftarrow x_1 - \vec{\delta}*\epsilon*c$ \\
		$x_2 \leftarrow x_2 + \vec{\delta}*\epsilon*c$ \\
	}
\end{algorithm}

Um outro método de restringir os ângulos é satisfazer a restrição de produto interno

$$(x_2-x_0) \cdot (x_1 - x_0) < \alpha$$

\subsection{Resolvendo restrições concorrentes por relaxamento}

Na prática, uma simulação pode conter muitas restrições de todos os tipos vistos anteriormente. Para satisfazer todas elas devemos resolver todas as inequações sequencialmente, como as restrições entre partículas são interdependentes, não é possível satisfazê-las todas simultaneamente de maneira exata em um único passo.

\citeonline{jakobsen2001advanced} propõe um método iterativo de relaxamento, também conhecido como \textit{Gauss-Seidel relaxation}, para resolver as restrições de forma aproximada.

Uma abordagem de solução indireta por iteração local que consiste em aplicar pequenas correções de posição para cada par de partículas conectado, repetindo o procedimento diversas vezes até que todas as restrições estejam aproximadamente satisfeitas. Cada iteração contribui para reduzir o erro acumulado, e a convergência ocorre rapidamente mesmo com poucas iterações (geralmente entre 3 e 5).

\begin{algorithm}
	\caption{Satisfazer Restrições}
	\KwIn{n: número de repetições}
	\For{$i \leftarrow 0$ \KwTo n}{
		ResolverRestrição(i)
	}
	\label{al:satisfazer_restricoes}
\end{algorithm}

Apesar dessa abordagem parecer ingênua, ao resolver todas restrições localmente e repetir, o sistema global do sistema converge para uma configuração que satisfaça todas restrições. Quanto maior o número de iterações mais rápido o sistema irá convergir para solução e também a animação irá parecer mais rígida para o usuário.

Além disso para o algoritmo \ref{al:linear_constraint} o valor e $\epsilon$ tem o efeito de aumentar o passo local de convergência para solução ideal. Fisicamente pode ser interpretado como um coeficiente de restituição. Pode ser usado para representar quão abrupto as partículas se aproximam ou afastam.
