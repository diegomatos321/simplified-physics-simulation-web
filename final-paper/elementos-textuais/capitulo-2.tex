\chapter{Animação baseado em física}

Na maioria dos casos, é preciso usar métodos sofisticados e exatos para simular a dinâmica. Porém, em aplicações de jogos interativos, a precisão não é realmente o mais importante, mas sim que o resultado final tenha uma aparência realista e que possa ser executado rapidamente. 

\citeonline{jakobsen2001advanced} apresentou um conjunto de métodos e técnicas que, unidas, conseguem atingir em grande parte estes objetivos. Estes métodos são relativamente simples de implementar (comparados com outros esquemas) e têm um bom desempenho. O algoritmo é iterativo e permite aumentar a precisão do método sacrificando parte de sua rapidez: se uma pequena fonte de imprecisão é aceita, o código pode conseguir uma execução mais rápida. Esta margem de erro ainda pode ser ajustada de forma adaptativa em tempo de execução.

Em geral, o sucesso deste método vem da combinação de varias técnicas que se beneficiam umas das outras, principalmente o uso do integrador Verlet, o tratamento de colisões usando projeção, e a resolução de restrições de distância usando relaxamento. A seguir serão descritas as componentes mais importantes da abordagem proposta por Jakobsen.

\section{Integrador Verlet}

O núcleo da simulação é um sistema de partículas, sua implementação mais simples é para cada passo calcular sua nova posição \textbf{x} e nova velocidade \textbf{v} com o sistema abaixo:

$$
\begin{cases}
	x' = x + v \cdot \Delta t \\
	v' = v + a \cdot \Delta t
\end{cases}
$$


Esse é o método de Euler sendo $\Delta t$ o tamanho do passo, \textbf{a} é aceleração calculado a partir da lei de newton $F = ma$ onde F é a força acumulada agindo na partícula.
%. É comum esses tipos de sistemas serem implementados com duas variáveis principais: posição x e velocidade v. Então para cada passo da simulação  

Existem muitos outros esquemas de integração como Runge-Kutta e outras variantes. Um método que é bem estável, sua velocidade é calculada implicitamente o quê mantém sua posição e velocidade em sincronia é o integrador de Verlet, muito popular em simulação de dinâmica molecular.

$$
\begin{cases}
	x' = 2x - x^* + a \cdot \Delta t^2 \\
	x^* = x
\end{cases}
$$

Sendo \textbf{x} sua posição corrente e \textbf{$x^*$} sua posição anterior, essa é chamada representação sem velocidade. Ao fim de cada passo conseguimos representar o sistema de partículas como:

$$
X = \begin{pmatrix}
	x_1 \\
	x^*_1 \\
	a_1 \\
	\vdots \\
	x_n \\
	x^*_n \\
	a_n \\
\end{pmatrix}
$$

O algoritmo para o integrador verlet segue como

\begin{algorithm}[H]
	\caption{Verlet}
	\KwIn{Tamanho do passo dt}
	\For{$i \leftarrow 0$ \KwTo n}{
		$x \leftarrow X[i]$ \\
		$x^* \leftarrow X[i+1]$ \\
		$a \leftarrow X[i+2]$  \\
		$x_{tmp} \leftarrow x$ \\
		
		$X[i] \leftarrow 2*x-x^* + a*dt$ \\
		$X[i+1] \leftarrow x_{tmp}$ \\
		$X[i+2] = 0$ \tcp{Limpa as forças para próxima iteração}
	}
\end{algorithm}

Como dito anteriormente, as vantagens de usar esse esquema proposta por \citeauthor{jakobsen2001advanced} serão evidenciadas quando combinadas com as próximas técnicas.

\section{Restrição Linear}

O sucesso de \citeonline{jakobsen2001advanced} não está relacionado apenas ao método numérico, mas foi conectar ideias simples para construir objetos maiores e complexos. Isso é feito atribuindo as partículas algo em comum, um conjunto de propriedades que devem ser respeitadas para atingir o efeito desejado.

A primeira propriedade - também é a base para as próximas - é chamada restrição linear ou restrição de distância. Ela apenas dita que duas partículas $p_0$ e $p_1$ devem sempre estar a uma distância d entre si. Dessa forma o conjunto de partículas devem satisfazer a todo instante uma coleção de inequações unilaterais representadas na forma:

\begin{equation}
	|x_2 - x_1| = d
	\label{eq:linear_constraint}
\end{equation}

Mesmo que as posições das partículas estejam inicialmente corretas, depois de um passo de simulação a distância entre elas pode se tornar inválidas (através de forças externas, por exemplo). Para corrigir sua distância devemos mover (projetar) elas de tal forma que satisfaça \ref{eq:linear_constraint}.

\textbf{Inserir figura}

A essência de uma restrição é a projeção. Deve-se encontrar o movimento mínimo que a satisfaça. O efeito de uma restrição linear pode representar conectar duas partículas com uma haste rígida mas também projetar o ponto em um círculo ao redor do ponto de ancoragem.

\begin{algorithm}[H]
	\caption{Restrição Linear}
	$\vec{\delta} \leftarrow x_2 - x_1$ \\
	$\epsilon \leftarrow \frac{|\vec{\delta}| - d}{|\vec{\delta}|}$ \\
	$x_1 \leftarrow x_1 - \vec{\delta}*0.5*\epsilon$ \\
	$x_2 \leftarrow x_2 + \vec{\delta}*0.5*\epsilon$ \\
	\label{al:linear_constraint}
\end{algorithm}

O pseudocódigo \ref{al:linear_constraint} irá separar ou aproximar as partículas de tal forma que satisfaçam a distancia $d$. Essa situação é comparável a um sistema de molas interconectadas entre partículas de rigidez que tendem para o infinito ou a uma haste rígida separando as duas partículas.

\section{Restrição de Revolução}

Na animação física queremos muitas vezes que uma partícula gire em torno de um eixo. Isso é feito de forma simples, basta ter uma partícula em comum cuja função seja ser um eixo de rotação.

\textbf{Inserir figura}

Uma outra forma de fazer isso é usar uma restrição linear com $d=0$.

\section{Restrição Angular}

Em muitas situações em animação física é desejável que o ângulo formado entre duas partículas esteja restrito a um intervalo válido. Isso pode ser feito de forma simples aplicando uma restrição linear caso a distância entre duas partículas seja menor que um limiar. Ou seja, satisfazer a inequação abaixo

$$|x_2 - x_1| > 100$$

Com essa restrição conseguimos modelar propriedades como joelhos e cotovelos de uma criatura que não podem dobrar além de ângulo máximo.

A rotina para essa restrição é tão simples quanto usar um condicional junto com o algoritmo de restrição linear.

\begin{algorithm}
	\caption{Restrição Angular}
	$\vec{\delta} \leftarrow x_2 - x_1$ \\
	\If{$\vec{|\delta|} < d$}{
		$\epsilon \leftarrow \frac{|\vec{\delta}| - d}{|\vec{\delta}|}$ \\
		$x_1 \leftarrow x_1 - \vec{\delta}*0.5*\epsilon$ \\
		$x_2 \leftarrow x_2 + \vec{\delta}*0.5*\epsilon$ \\
	}
\end{algorithm}

Um outro método de restringir os ângulos é satisfazer a restrição de produto interno

$$(x_2-x_0) \cdot (x_1 - x_0) < \alpha$$


\section{Resolvendo restrições concorrentes por relaxamento}

Na prática, uma simulação pode conter muitas restrições de todos os tipos vistos anteriormente. Para satisfazer todas elas devemos resolver todas as inequações sequencialmente, isso seria o equivalente a encontrar a solução de um sistema de equações.

Entretanto \citeonline{jakobsen2001advanced} propõe uma abordagem de solução indireta por iteração local, basta satisfazer todas restrições e repetir um número $N$ vezes a cada passo da simulação

\begin{algorithm}
	\caption{Satisfazer Restrições}
	\KwIn{n: número de repetições}
	\For{$i \leftarrow 0$ \KwTo n}{
		ResolverRestrição(i)
	}
	\label{al:satisfazer_restricoes}
\end{algorithm}

Apesar dessa abordagem parecer ingênua, ao resolver todas restrições localmente e repetir, o sistema global do sistema converge para uma configuração que satisfaça todas restrições. Quanto maior o número de iterações mais rápido o sistema irá convergir para solução e também a animação irá parecer mais rígida para o usuário.

Além disso para o \ref{al:linear_constraint} a constante 0,5 também tem o efeito de aumentar o passo local de convergência para solução ideal. Fisicamente pode ser interpretado como um coeficiente de restituição. Pode ser usado para representar quão abrupto as partículas se aproximam ou afastam.
