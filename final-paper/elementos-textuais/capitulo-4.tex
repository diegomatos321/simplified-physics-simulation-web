\chapter{Detecção de Colisões}

A detecção de colisões é um componente fundamental em sistemas de simulação física e em animações baseadas em partículas. Esse processo identifica quando dois ou mais objetos entram em contato, determina pontos de interseção e, quando necessário, fornece informações como vetores de penetração e normais que servirão de entrada para a etapa subsequente de resposta física. Em contextos interativos em tempo real, a precisão geométrica absoluta costuma ser sacrificada em favor da eficiência computacional, desde que o comportamento resultante se mantenha visualmente verossímil.

Este capítulo introduz os principais conceitos utilizados no âmbito deste trabalho, descrevendo as representações geométricas mais comuns para objetos convexos e apresentando dois algoritmos amplamente empregados em detecção de colisões: o Teorema do Eixo Separador (SAT) e o algoritmo Gilbert--Johnson--Keerthi (GJK). Ambos operam eficientemente em formas convexas e constituem a base de vários motores físicos modernos.

\section{Polígonos convexos}

Um objeto geométrico é definido como um conjunto não vazio, limitado e fechado de pontos. A propriedade de ser fechado implica que sua fronteira pertence ao próprio conjunto, enquanto a limitação garante que exista uma esfera de raio finito que contenha todos os seus pontos. Um plano, por exemplo, é fechado, mas não limitado.

\textbf{(INSERIR IMAGEM DE FORMA CONVEXA E NÃO-CONVEXA)}

Uma forma é considerada \textit{convexa} se, para quaisquer dois pontos contidos nessa forma, todo o segmento que os une também estiver contido nela. Uma consequência prática é que, para qualquer linha que atravesse o objeto, esta o intersecta em no máximo dois pontos. Formas não convexas podem ser tratadas como composições de múltiplas partes convexas, o que permite a aplicação direta de algoritmos especializados.

\section{Teorema do Eixo Separador (SAT)}
\label{sec:sat}

O Teorema do Eixo Separador (\textit{Separating Axis Theorem}, SAT) é um dos métodos mais difundidos para detecção de colisão entre polígonos convexos. Além de identificar a presença ou ausência de interseção, o SAT também pode ser utilizado para calcular o \textit{vetor de translação mínima} (\textit{Minimum Translation Vector}, MTV), útil para correções geométricas e resposta física.

O SAT é um algoritmo genérico rápido que pode remover a necessidade de ter código de detecção de colisão para cada par tipo de forma, reduzindo assim o código e a manutenção. Ele se baseia no teorema geométrico que afirma:

\begin{teorema}
	Dois polígonos convexos $A$ e $B$ não se intersectam se, e somente se, existir um eixo (reta) sobre o qual as projeções de $A$ e $B$ não se sobrepõem.
	\label{theo:sat}
\end{teorema}

\textbf{INSERIR IMAGEM POLIGONO SEPARADO E POLIGONO EM COLISÃO}

Um \textit{plano de separação} (PS), definido por um vetor normal $v$ e um escalar $\delta$, é um hiperplano que separa $A$ e $B$. Em termos computacionais, o SAT testa um conjunto finito de eixos candidatos — tipicamente as normais às arestas dos polígonos — verificando se existe algum eixo que sirva como separador.

\subsection{Projeção sobre um eixo}

Dado um eixo unitário $\hat{n}$ e um conjunto de vértices $\{ v_i \}$, a projeção escalar do polígono sobre $\hat{n}$ é dada pelos extremos:
\begin{align}
	\text{min}_A &= \min_i (\hat{n} \cdot v_i^A) \\
	\text{max}_A &= \max_i (\hat{n} \cdot v_i^A)
\end{align}

De forma análoga, para o segundo polígono $B$:
\begin{align}
	\text{min}_B &= \min_j (\hat{n} \cdot v_j^B) \\
	\text{max}_B &= \max_j (\hat{n} \cdot v_j^B)
\end{align}

Se os intervalos $[\text{min}_A, \text{max}_A]$ e $[\text{min}_B, \text{max}_B]$ não se sobrepõem em algum eixo $\hat{n}$, então os polígonos não colidem.

\subsection{Teste de interseção booleana}

O pseudocódigo abaixo resume o teste booleano de interseção via SAT:

\begin{algorithm}[H]
	\caption{Teste booleano de colisão via SAT}
	\KwIn{Polígonos convexos $A$ e $B$}
	\KwOut{Verdadeiro se houver interseção}
	\ForEach{aresta $e$ de $A$ e $B$}{
		$\hat{n} \leftarrow$ normal unitária de $e$ \\
		$p_i \leftarrow$ Projeção de $A$ ao longo de $\hat{n}$ \\
		$p_j \leftarrow$ Projeção de $B$ ao longo de $\hat{n}$ \\
		\If{$p_i$ não sobrepõe $p_j$}{
			\Return{False}
		}
	}
	\Return{True}
	\label{al:sat_1}
\end{algorithm}

O método possui complexidade linear no número de arestas e é bastante eficiente para polígonos convexos em 2D. Em 3D, entretanto, o número de eixos candidatos cresce significativamente, reduzindo sua praticidade em relação a alternativas como o GJK.

\subsection{Vetor de Translação Mínima (MTV)}

Para aplicações que exigem resposta física, é necessário calcular não apenas a detecção de colisão, mas também o deslocamento mínimo para separar os objetos. O MTV é obtido identificando-se o eixo cuja sobreposição projetada é mínima.

\begin{algorithm}
	\caption{SAT com cálculo do MTV}
	\KwIn{Polígonos convexos $A$ e $B$}
	\KwOut{Direção $v$ e penetração $\delta$, ou falso}
	$v \leftarrow 0$ \\
	$\delta \leftarrow \infty$ \\
	\ForEach{aresta $e$ de A e B}{
		$\hat{n} \leftarrow$ normal unitária de $e$ \\
		$p_1 \leftarrow$ Projeção de $A$ \\
		$p_2 \leftarrow$ Projeção de $B$ \\
		$\Delta \leftarrow$ sobreposição entre $p_1$ e $p_2$ \\
		\If{$\Delta \leq$ TOLERÂNCIA}{
			\Return{False}
		}
		\If{$\Delta < \delta$}{
			$\delta \leftarrow \Delta$ \\
			$v \leftarrow \hat{n}$
		}
	}
	\Return{$v$, $\delta$}
	\label{al:sat_2}
\end{algorithm}

\section{Algoritmo Gilbert–Johnson–Keerthi (GJK)}

O algoritmo de \citeonline{gjk} calcula a distância mínima entre dois conjuntos convexos utilizando apenas uma \textit{função de suporte} capaz de retornar o ponto mais distante de um conjunto em uma direção arbitrária. Esse algoritmo é particularmente eficiente em 3D e é amplamente adotado em motores físicos por sua robustez e excelente desempenho.

\subsection{Soma de Minkowski}

O algoritmo GJK depende muito de um conceito chamado soma de Minkowski de dois objetos convexos A e B que é definida por:

\begin{equation}
	A + B = \{\vec{x} + \vec{y} \mid \vec{x} \in A, \vec{y} \in B \},
\end{equation}

O objeto A + B é o conjunto de pontos obtido por um processo de varredura que translada o centro de massa de B para cada ponto de A, ou seja, faz-se uma cópia do objeto B centrado em cada ponto de A

(INSERIR FIGURA SOMA DE MINKOWSKI)

Uma propriedade muito útil da soma de Minkowski é o fato de que a soma de dois objetos convexos é um objeto convexo. O algoritmo GJK se beneficia dessas propriedades usando uma operação informalmente chamada de \textit{diferença de Minkowski}

\begin{equation}
	A - B = \{\vec{x} - \vec{y} \mid \vec{x} \in A, \vec{y} \in B \},
\end{equation}

A diferença de Minkowski pode ser pensado como um processo de varredura que calcula o vetor distancia para cada ponto de B em A. Dessa forma, caso a distância entre dois pontos seja zero (interseção), podemos confirmar a colisão entre os dois objetos. Esse vetor também coincide com a origem, logo elaboramos nosso próximo teorema:

Essa operação continua sendo a soma de Minkowski (a soma da diferença). Mas neste trabalho usaremos esse termo para referir a essa operação quando necessário.

Executar essa operação exige $|A| * |B| * 2$ subtrações. Isso é significativo porque uma forma é composta de um número infinito de pontos. Uma vez que ambas as formas são convexas e definidas por vértices mais externos só precisamos realizar esta operação nos vértices. A grande coisa sobre GJK é que você realmente não precisa calcular a diferença de Minkowski para todos os vértices.

\begin{teorema}
	Os conjuntos $A$ e $B$ colidem se, e somente se, o ponto de origem $(0, 0)$ estiver contido em $A \ominus B$.
\end{teorema}

Dessa forma, não queremos calcular a diferença de Minkowski. Em vez disso, queremos apenas saber se a Diferença de Minkowski contém ou não a origem. Se isso acontecer, então sabemos que as formas estão se cruzando, se não o faz, então elas não são.

Isso é feito construindo iterativamente um polígono dentro da diferença de Minkowski que tenta incluir a origem. Se o polígono que construímos contém a origem, então podemos dizer que a Diferença de Minkowski contém a origem, e também que há interseção entre os dois objetos. Este polígono que queremos construir deve ser da forma mais elementar possível, no caso de 2D um triângulo, no caso de 3D um poliedro, por isso é chamado de Simplex.

\subsection{Função de Suporte}

O algoritmo GJK começa com um simplex inicial e o refina iterativamente adicionando pontos encontrados usando a função de suporte em uma direção que aponta para a origem. Esse processo continua até que a origem seja encontrada dentro do simplex, indicando uma colisão, ou até que se determine que a origem não está contida, o que significa que não há colisão.

A função de suporte deve retornar o ponto mais distante em uma direção dentro da Diferença de Minkowski. Isso cria um Simplex que contém uma área máxima, aumentando, portanto, a chance de que o algoritmo termine rapidamente. Além disso, podemos usar o fato de que todos os pontos retornados desta forma estão na borda da Diferença Minkowski e, portanto, se não pudermos adicionar um ponto além da origem ao longo de alguma direção, sabemos que a Diferença de Minkowski não contém a origem. Isso aumenta as chances de o algoritmo sair rapidamente em casos de não interseção.

\subsection{Construção iterativa do simplex}

O GJK constrói iterativamente um \textit{simplex} (ponto, segmento, triângulo ou tetraedro, dependendo da dimensão) que aproxima a origem dentro de $A \ominus B$.  

%Mesmo seguindo todos esses critérios ainda podemos não obter um Simplex que contém a origem nessas três etapas. Devemos criar iterativamente o Simplex de tal forma que o Simplex esteja se aproximando de conter a origem. Também precisamos verificar duas condições ao longo do caminho: 1) o simplex atual contém a origem? e 2) somos capazes de incluir a origem?


\begin{algorithm}[H]
	\caption{GJK}
	\LinesNumbered
	\KwIn{Polígonos convexos $A$ e $B$}
	\KwOut{Verdadeiro se ocorreu colisão}
	
	Escolhe-se uma direção inicial $\vec{d}$; \\
	$p \leftarrow \text{support}(A \ominus B, \vec{d})$ \\
	\If{$p \cdot \vec{d} < 0$}{
		\Return{False}
	}
	Atualiza-se o simplex com $p$ e calcula-se nova direção $\vec{d}$; \\
	Itera-se até que o simplex contenha a origem ou seja possível concluir ausência de interseção.
\end{algorithm}

O GJK é eficiente e converge rapidamente na prática, sendo mais apropriado que o SAT em cenários tridimensionais e em motores físicos de uso geral.

%\begin{algorithm}[H]
%	\caption{GJK}
%	\KwIn{Polígonos convexos A e B}
%	\KwOut{Verdadeiro se ocorreu colisão}
%	
%	d $\leftarrow$ B - A \tcp{Direção inicial aponta para o centro de B}
%	simplex $\leftarrow$ support(A, B, d) \\
%	d $\leftarrow$ -d \tcp{Inverte a direção para próxima iteração}
%	\For{$i \leftarrow 0$ \KwTo MAX\_INTERATION}{
%		$a \leftarrow support(A, B, d)$ \\
%		\If{$a \cdot d \leq 0$}{
%			\KwRet{false}
%		}
%		
%		simplex $\leftarrow$ a \\
%		\If{simplex contém a origem}{
%			\KwRet{true}
%		}
%		
%		d $\leftarrow$ calcular próxima direção
%	}
%	
%	\label{al:gjk}
%\end{algorithm}

%Podemos determinar onde está a origem com relação ao simplex através da realização de uma série de testes em plano (testes de linha para 2D) onde cada teste consiste em produtos de pontos simples. O primeiro caso que deve ser tratado é o caso do segmento de linha. Podemos determinar se o simplex contém a origem examinando as regiões de Voronoi
%
%\begin{algorithm}[H]
%	\caption{Contém Origem}
%	\KwIn{simplex}
%	\KwOut{Boolean}
%	
%	\If{|simplex| == 4}{ \tcp{Caso 3D}
%		\KwRet{TestePoliedro()}
%	} \ElseIf{|simplex| == 3} { \tcp{Caso 2D}
%		\KwRet{TesteTriangulo()}
%	} \Else{
%		\KwRet{TesteLinha()}
%	}
%\end{algorithm}

%\section{Polígonos côncavos}
%
%\section{Tratando casos degenerados}
