\chapter{Introdução}

A evolução da capacidade computacional e das placas gráficas nas últimas décadas permitiu o desenvolvimento de simulações visuais cada vez mais realistas. Dentro desse contexto, a \textbf{Computação Gráfica} surge como uma área fundamental da ciência da computação responsável por estudar técnicas e algoritmos para gerar, manipular e representar imagens digitais de maneira eficiente e visualmente convincente. Essa área abrange desde o simples desenho de primitivas geométricas até a renderização de ambientes tridimensionais complexos, sendo amplamente utilizada em aplicações de engenharia, design, entretenimento e educação.

Segundo \citeonline{azevedo2003}, a computação gráfica é matemática e arte. Esta ferramenta proporciona um maior poder de abstração, ajudando na criação de imagens complexas e em muitos casos não imaginadas. A computação gráfica pode ser encarada como uma ferramenta não convencional que permite ao artista transcender das técnicas tradicionais de desenho ou modelagem.

Em paralelo, o avanço dos \textbf{programas interativos}, especialmente jogos eletrônicos e simulações físicas em tempo real, intensificou a necessidade de técnicas capazes de combinar realismo visual com desempenho computacional. De acordo com \citeonline{moller2018} num programa interativo, uma imagem é exibida, o usuário reage, e essa reação influencia as próximas imagens a serem geradas.
Esse ciclo de interação deve ocorrer a uma taxa suficientemente alta para que o usuário não veja imagens individuais, mas sim se sinta imerso em um processo dinâmico. A taxa na qual as imagens são exibidas é medida em quadros por segundo (FPS) ou Hertz (Hz). Para aplicações interativas, requer-se ao menos uma taxa de 6 FPS sendo que taxas mais elevadas tornam a experiência mais mais imersiva.

Um tipo de programa interativo são as que fazem \textbf{animações} que podem ser feitas tradicionalmente baseadas em quadros-chave (\textit{keyframe animation}) onde o movimento dos objetos é previamente definido pelo artista, ou \textbf{baseado em física} onde o movimento dos objetos devem seguir leis físicas o quê permite gerar comportamentos emergentes e interações físicas naturais. Contudo, implementar esse tipo de sistema envolve desafios como equilibrar precisão física e desempenho computacional.

Este trabalho está interessado em realizar animação físicas 2D em Web pois é um problema interessante muito usado em jogos que pode se beneficiar da combinação de \textbf{WebGL}, \textbf{JavaScript} e \textbf{Web Workers}. WebGL proporciona renderização acelerada por GPU diretamente no navegador, enquanto JavaScript garante ampla acessibilidade e rápida prototipação. A utilização de Web Workers permite distribuir a simulação física em paralelo, evitando bloqueios na \textit{main thread} e mantendo o desempenho da renderização. Esse ecossistema torna a plataforma Web um ambiente cada vez mais relevante para jogos, simulações científicas e aplicações educacionais, motivando o foco deste trabalho em uma animação física simplificada e otimizada para navegadores.

Uma animação física consiste, no geral, em uma série de corpos que se movem com propriedades físicas que regem os objetos (massa, posição, velocidade, aceleração, deformidade, forma do objeto, etc) que precisam ser simuladas e as características geométricas do objeto que devem ser levadas consideração quando um objeto colide com outro. É preciso saber se houve colisão e como essa colisão devem ser tratadas e resolvidas, por isso uma animação física é complicada pois leva em consideração geometria e física. 

Para lidar com essa complexidade, diversas técnicas são empregadas na literatura, como a \textbf{detecção de colisões em múltiplas fases} (Broad Phase e Narrow Phase), o uso de \textbf{estruturas espaciais otimizadas} (como grades uniformes) e estratégias de \textbf{processamento paralelo}.

Esses problemas são tão importantes que já foram abordados por outras pessoas pois se tem grande interesse então já existem bibliotecas para resolver isso que alavancam hardware gráfico para melhorar o desempenho entre os quais podemos citar motores físicos comerciais e de código aberto como \textbf{Havok} popularizou o uso profissional de física em jogos de grande porte, oferecendo um sistema robusto de colisões e restrições. O \textbf{NVIDIA PhysX} introduziu aceleração por GPU, permitindo simulações mais ricas. Motores como \textbf{Bullet Physics} e \textbf{Box2D}, ambos de código aberto, democratizaram o acesso a ferramentas de alta qualidade, tornando-se amplamente adotados em pesquisas, jogos independentes e aplicações embarcadas.

 Para o desenvolvimento do jogo \textit{Hitman: Codename 47}, Jakobsen propôs um esquema simplificado de simulação física que é capaz de modelar corpos rígidos e deformáveis, e tecidos, sem computar explicitamente matrizes de orientação, torques ou tensores de inércia. Seu método combina manutenção iterativa de restrições, \textbf{resposta a colisões por projeção} e uso de aproximações eficientes. Entretanto, o método omite diversos detalhes importantes, como estratégias de detecção de colisões, tratamento de um grande número de restrições e mecanismos de otimização para múltiplos objetos -- lacunas que este trabalho busca explorar.

Neste trabalho, o objetivo é desenvolver um protótipo inspirado no método de Jakobsen, apresentando soluções para detecção e resposta a colisões com foco em aplicações Web. São metas específicas:

\begin{itemize}
	\item Revisar os principais conceitos de animação baseada em física e integração numérica;
	\item Implementar algoritmos de detecção de colisão como GJK e SAT
	\item Desenvolver uma simulação física baseada em partículas e restrições utilizando o método de Jakobsen;
	\item Aplicar técnicas de otimização e processamento multi-threaded;
	\item Avaliar o desempenho e a estabilidade do sistema em diferentes cenários.
\end{itemize}

O Capítulo 2 apresenta animação baseada em física com método Jakobsen, servindo como alicerce para a simulação. O Capítulo 3 descreve os algoritmos essenciais para a detecção de colisões, como o SAT e o GJK. Em seguida, o Capítulo 4 explica as técnicas de resposta a colisão, incluindo a projeção de posição e o algoritmo EPA. O Capítulo 5 foca nas estratégias de otimização para garantir o desempenho em tempo real, cobrindo as fases Broad Phase e Narrow Phase, o uso de volumes delimitadores e o processamento multi-thread. O Capítulo 6 apresenta a metodologia experimental, a avaliação do sistema e a discussão dos resultados obtidos. Por fim, o Capítulo 7 resume as contribuições do trabalho, discute limitações e propõe direções para trabalhos futuros
