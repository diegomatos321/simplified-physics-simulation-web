\chapter{Introdução}

O campo da Computação Gráfica evoluiu significativamente nas últimas décadas, impulsionado pelo aumento da capacidade computacional e pela especialização do hardware gráfico. Esta área investiga métodos e algoritmos para gerar, manipular e representar imagens digitais de forma eficiente, desempenhando um papel central em aplicações de design, engenharia, entretenimento e visualização científica. Como destaca \citeonline{azevedo2003}, a computação gráfica combina matemática e arte, oferecendo meios para representar fenômenos complexos e criar imagens inviáveis pelos métodos tradicionais. Ela pode ser encarada, portanto, como uma ferramenta que permite ao artista transcender as limitações das técnicas convencionais de desenho ou modelagem.

Em paralelo, o avanço dos programas interativos, especialmente jogos eletrônicos e simulações físicas em tempo real, intensificou a necessidade de técnicas capazes de combinar realismo visual com desempenho computacional. De acordo com \citeonline{moller2018} num programa interativo, uma imagem é exibida, o usuário reage, e essa reação influencia as próximas imagens a serem geradas.
Esse ciclo de interação deve ocorrer a uma taxa suficientemente alta para que o usuário não veja imagens individuais, mas sim se sinta imerso em um processo dinâmico. A taxa na qual as imagens são exibidas é medida em quadros por segundo (FPS) ou Hertz (Hz). Para aplicações interativas, requer-se ao menos uma taxa de 6 FPS sendo que taxas mais elevadas tornam a experiência mais mais imersiva.

No contexto das aplicações interativas, destacam-se aquelas que realizam animação, isto é, a produção de imagens dinâmicas que representam objetos em movimento. Em geral, essas animações podem ser classificadas em dois grandes grupos: (i) animações \textit{keyframe}, nas quais artistas definem manualmente os quadros-chave e as interpolações; e (ii) animações baseadas em física, em que os movimentos emergem da simulação de leis físicas, permitindo comportamentos naturais e interações complexas entre objetos.

O presente trabalho aborda a implementação de animação física 2D na Web. A escolha deste tema justifica-se por sua ampla aplicabilidade em jogos digitais, simuladores educacionais e interfaces visuais interativas. A popularidade do problema decorre de sua relevância prática e de seus desafios teóricos, que envolvem tanto a modelagem geométrica dos objetos quanto sua evolução temporal segundo princípios físicos.

Diversos jogos e motores gráficos modernos adotam animações físicas para produzir experiências imersivas e responsivas. Exemplos incluem sistemas de queda, \textit{ragdolls}, tecidos, corpos rígidos e fluidos. Em todos esses casos, a simulação envolve um conjunto de corpos que possuem propriedades físicas — como massa, forma, velocidade e aceleração — e cujas interações são determinadas por colisões, forças e restrições. Uma animação física une dois domínios: a geometria, necessária para detectar e calcular contatos, e a física, responsável pela evolução dinâmica dos corpos.

De forma geral, um sistema de animação física segue o seguinte esquema: (i) definição dos corpos e de suas propriedades físicas; (ii) integração numérica para atualizar suas posições e velocidades; (iii) detecção de colisões, que identifica se e como os objetos se interceptam; (iv) resposta às colisões, que corrige interpenetrações e determina novas velocidades; e (v) renderização dos resultados ao usuário. Por sua natureza iterativa e dependente de múltiplos módulos, trata-se de um problema complexo, sensível ao desempenho e à precisão.

A relevância dessa classe de problemas motivou o desenvolvimento de diversos motores de física que alavancam hardware gráfico para melhorar o desempenho. Entre os quais podemos citar motores físicos comerciais e de código aberto como o Havok~\cite{havok} popularizou o uso profissional de física em jogos de grande porte, oferecendo um sistema robusto de colisões e restrições. O NVIDIA PhysX~\cite{physx} introduziu aceleração por GPU, permitindo simulações mais ricas. Motores como Bullet Physics e Box2D, ambos de código aberto, democratizaram o acesso a ferramentas de alta qualidade, tornando-se amplamente adotados em pesquisas, jogos independentes e aplicações embarcadas. Tais ferramentas demonstram a importância do tema e como algoritmos otimizados, aliados a hardware moderno, permitem simulações estáveis em tempo real.

Jakobsen~\cite{jakobsen2001advanced} propôs durante o desenvolvimento do jogo \textit{Hitman: Codename 47} um esquema simplificado de simulação física que é capaz de modelar corpos rígidos e deformáveis, e tecidos, sem computar explicitamente matrizes de orientação, torques ou tensores de inércia. Seu método combina manutenção iterativa de restrições, resposta a colisões por projeção e uso de aproximações eficientes. Entretanto, o método omite diversos detalhes importantes, como estratégias de detecção de colisões, tratamento de um grande número de restrições e mecanismos de otimização para múltiplos objetos -- lacunas que este trabalho busca explorar.

Independentemente da complexidade da simulação física, toda aplicação interativa requer um módulo final de renderização, responsável por apresentar ao usuário o estado atualizado da cena. No contexto Web, tecnologias como WebGL e Canvas permitem que essa etapa seja realizada com aceleração gráfica, integrando o fluxo completo de animação física em tempo real.

Neste trabalho, o objetivo é desenvolver um protótipo inspirado no método de Jakobsen, apresentando soluções para detecção e resposta a colisões com foco em aplicações Web. São metas específicas:
\begin{itemize}
	\item Revisar os principais conceitos de animação baseada em física e integração numérica;
	\item Implementar algoritmos de detecção de colisão como GJK e SAT
	\item Desenvolver uma simulação física baseada em partículas e restrições utilizando o método de Jakobsen;
	\item Aplicar técnicas de otimização e processamento multi-threaded;
	\item Avaliar o desempenho e a estabilidade do sistema em diferentes cenários.
\end{itemize}

O trabalho está organizado da seguinte forma: O Capítulo 2 fundamenta a animação baseada em física e detalha o método de Jakobsen. O Capítulo 3 descreve os algoritmos essenciais para a detecção de colisões (SAT e GJK). O Capítulo 4 aborda as técnicas de resposta a colisão, incluindo projeção de posição e o algoritmo EPA (\textit{Expanding Polytope Algorithm}). O Capítulo 5 foca nas estratégias de otimização para tempo real, cobrindo as fases \textit{Broad Phase} e \textit{Narrow Phase}, volumes delimitadores e processamento \textit{multi-thread}. O Capítulo 6 apresenta a metodologia experimental e a discussão dos resultados. Por fim, o Capítulo 7 resume as contribuições, discute limitações e propõe trabalhos futuros.
